#!/bin/bash
#
# .bash_env
#
# John Van Note
# 2017-02-27
#
# Sets environmental variables for bash
#

DEBUG='false';

# Determine terminal capabilites
tp='tput';
tps=$tp' setaf';
reset=$tp' sgr0';
if $tps 1 &> /dev/null;
then
    reset=$tp' sgr0';
    #$reset;
    #bold=$($tp bold);
    yellow=$($tps 136);
    orange=$($tps 166);
    red=$($tps 124);
    magenta=$($tps 125);
    violet=$($tps 61);
    blue=$($tps 33);
    cyan=$($tps 37);
    green=$($tps 64);
    black=$($tps 0);
    white=$($tps 15);
    #$reset
fi

# This is lifted from https://github.com/jessfraz/dotfiles/blob/master/.bash_prompt
prompt_git() {
    local s='';
    local branchName='';

    # Check if the current directory is in a Git repository.
    if [ "$(git rev-parse --is-inside-work-tree &>/dev/null; echo "${?}")" == '0' ]; 
    then

        # check if the current directory is in .git before running git checks
        if [ "$(git rev-parse --is-inside-git-dir 2> /dev/null)" == 'false' ]; then

            if [[ -O "$(git rev-parse --show-toplevel)/.git/index" ]]; then
                git update-index --really-refresh -q &> /dev/null;
            fi;

            # Check for uncommitted changes in the index.
            if ! git diff --quiet --ignore-submodules --cached; then
                s+='+';
            fi;

            # Check for unstaged changes.
            if ! git diff-files --quiet --ignore-submodules --; then
                s+='!';
            fi;

            # Check for untracked files.
            if [ -n "$(git ls-files --others --exclude-standard)" ]; then
                s+='?';
            fi;

            # Check for stashed files.
            if git rev-parse --verify refs/stash &>/dev/null; then
                s+='$';
            fi;

        fi;

        # Get the short symbolic ref.
        # If HEAD isnâ€™t a symbolic ref, get the short SHA for the latest commit
        # Otherwise, just give up.
        branchName="$(git symbolic-ref --quiet --short HEAD 2> /dev/null || \
            git rev-parse --short HEAD 2> /dev/null || \
            echo '(unknown)')";

        [ -n "${s}" ] && s=" [${s}]";

        echo -e "${1}${branchName}${blue}${s}";
    else
        return;
    fi;
}

if [ "$DEBUG" = true ];
then
    tests="this is ${yellow} yellow,";
    tests+="${orange} orange,";
    tests+="${red} red,";
    tests+="${magenta} magenta,";
    tests+="${violet} violet,";
    tests+="${blue} blue,";
    tests+="${cyan} cyan,";
    tests+="${green} green,";
    tests+="${black} black, ";
    tests+="and ${bold} bold";
    #$reset;
    echo $tests
    unset tests
fi

# Prompt Statements
PS1="";
#PS1+="\[${reset}\]";
PS1+="\[${blue}\]\u";
PS1+="\[${white}\] at ";
PS1+="\[${cyan}\]\h";
PS1+="\[${white}\] in ";
PS1+="\[${violet}\w";
PS1+="\$(prompt_git \"${white} on ${magenta}\")"
PS1+="\n";
PS1+="\[${white}\] ~ ";
export PS1;

PS2="";
PS2+="... ";
export PS2;
